<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="读书笔记,MySQL," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.1" />






<meta name="description" content="TL;DR  《深入浅出MySQL》是讲MySQL不可多得的好书，做法和背后的原理都涉及。索引和锁，show variables 查看参数，优化SQL的几大步骤等，是这本书的核心。不过这篇文章作为记录性笔记，参考意义更大些，可读性可能不是很强。  第一部分 基础篇支持的数据类型 数值类型 整数类型。按照取值不同，有ti">
<meta name="keywords" content="读书笔记,MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入浅出MySQL》笔记">
<meta property="og:url" content="http://yoursite.com/2017/04/10/head-first-mysql/index.html">
<meta property="og:site_name" content="daorren&#39;s Secrets">
<meta property="og:description" content="TL;DR  《深入浅出MySQL》是讲MySQL不可多得的好书，做法和背后的原理都涉及。索引和锁，show variables 查看参数，优化SQL的几大步骤等，是这本书的核心。不过这篇文章作为记录性笔记，参考意义更大些，可读性可能不是很强。  第一部分 基础篇支持的数据类型 数值类型 整数类型。按照取值不同，有tinyint、smallint、mediumint、int、bigint。指定显示">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-11-20T02:57:56.750Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《深入浅出MySQL》笔记">
<meta name="twitter:description" content="TL;DR  《深入浅出MySQL》是讲MySQL不可多得的好书，做法和背后的原理都涉及。索引和锁，show variables 查看参数，优化SQL的几大步骤等，是这本书的核心。不过这篇文章作为记录性笔记，参考意义更大些，可读性可能不是很强。  第一部分 基础篇支持的数据类型 数值类型 整数类型。按照取值不同，有tinyint、smallint、mediumint、int、bigint。指定显示">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 《深入浅出MySQL》笔记 | daorren's Secrets </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97826694-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">daorren's Secrets</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                《深入浅出MySQL》笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-10T10:16:37+00:00" content="2017-04-10">
              2017-04-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>TL;DR</p>
<blockquote>
<p>《深入浅出MySQL》是讲MySQL不可多得的好书，做法和背后的原理都涉及。索引和锁，show variables 查看参数，优化SQL的几大步骤等，是这本书的核心。不过这篇文章作为记录性笔记，参考意义更大些，可读性可能不是很强。</p>
</blockquote>
<h2 id="第一部分-基础篇"><a href="#第一部分-基础篇" class="headerlink" title="第一部分 基础篇"></a>第一部分 基础篇</h2><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><ul>
<li>数值类型<ul>
<li>整数类型。按照取值不同，有tinyint、smallint、mediumint、int、bigint。<br>指定显示宽度，如int(5)，默认为int(11)，常与zerofill同用，也就是不够长用0填空。存储数据超过宽度限制时，宽度限制不再有意义。<br>属性 UNSIGNED（无符号）。tinyint有符号范围是 -127~+127，而无符号范围是 0~255。<br>属性 AUTO_INCREMENT。插入NULL到此列时，MySQL插入一个比该列当前最大值大1的值。</li>
<li>小数<ul>
<li>浮点数。包括float单精度和double双精度。</li>
<li>定点数。只有decimal一种表示。（注：这里我不懂linux的数值表示，浮点定点是基于二进制表示）<br>小数可以在类型名称后加(M, D)，表示该值一共显示M位数字，其中D位位于小数点后面。M和D称为精度和标度。<br>浮点数不指定精度时，会按照实际精度（硬件和操作系统决定），而定点数不指定精度时，默认为(10, 0)。<br>注意，超过精度的数值，会被截断；而在传统的SQL Mode下，记录将无法插入。</li>
</ul>
</li>
<li>BIT位类型。存放二进制数，使用时需要 <code>select bin(column)</code> 或者 <code>select hex(column)</code>。</li>
</ul>
</li>
<li>日期时间类型<ul>
<li>Date只保存日期，Time只保存时分秒，Datetime保存日期加时分秒。Year只保存年。</li>
<li>Timestamp。支持范围较小，表中第一个Timestamp列自动设置为系统时间。Timestamp与时区有关，插入查询都会先转换成本地时区。</li>
</ul>
</li>
<li>字符串类型<ul>
<li>CHAR与VARCHAR。用户保存较短字符，主要区别是存储方式。CHAR列的长度固定为创建表时声明的长度，VARCHAR列保存可变长字符串。<br>另外，查询的时候，CHAR列删除末尾的空格，而VARCHAR则保留空格。（改小VARCHAR限制，性能不会提高）</li>
<li>ENUM。枚举类型，255个成员以下用1个字节，65535个成员以下用2个字节。一次只能取单个值</li>
<li>SET。类似ENUM，存储64个成员以下，占用字节数也大，但一次能取多个值</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>使用时都要带括号，如 <code>select curdate()</code></p>
<ul>
<li>字符串函数。concat、insert（从指定位置开始子串替换）、lower、upper、left、right（返回左右指定长度字符）、lpad、rpad（填充到左右直到指定长度）、<br>ltrim、rtrim（去除左右空格）、repeat、replace（替换指定字符串）、trim（去掉头尾空格）、substring（返回子串）</li>
<li>数值函数。abs、ceil、floor、mod、rand（0-1内随机值）、round（四舍五入）、truncate。</li>
<li>日期函数。curdate、curtime、now、unix_timestamp、week、year、monthname、date_formate、datediff（起止时间之间的天数）</li>
<li>流程函数。if(value, t, f)、case [expr] when [value1] then [result1]…else [default] end</li>
</ul>
<h2 id="第二部分-开发篇"><a href="#第二部分-开发篇" class="headerlink" title="第二部分 开发篇"></a>第二部分 开发篇</h2><h3 id="表类型（存储引擎）的选择"><a href="#表类型（存储引擎）的选择" class="headerlink" title="表类型（存储引擎）的选择"></a>表类型（存储引擎）的选择</h3><p>MySQL的插件式存储引擎是其最重要的特性之一。其中InnoDB和BDB提供事务安全表，其他存储引擎提供非事务安全表。<br>5.5之前默认引擎是 MyISAM，5.5之后是InnoDB。 查看 <code>show engines;</code></p>
<ul>
<li>存储引擎特性<ul>
<li>MyISAM。不支持事务，不支持外键，优势是访问速度快。<br>每个MyISAM表在磁盘上存储成三个文件，文件名与表名相同，扩展名是 .frm（表定义），.MYD（表数据），.MYI（表索引）。<br>数据文件和索引文件可以放在不同目录（建表时指定），平均分布IO，获得更快的速度。<br>MyISAM表可能会损坏，损坏表可能不能被访问。 check table 来检查MyISAM表的健康，repair table 来修复损坏。<br>支持三种存储格式，静态表、动态表、压缩表。<ul>
<li>静态表。默认存储格式。字段都是非变长字段，记录都是定长，优点是存储快速易缓存，缺点是占用空间比动态表多。存储时会用空格补足列宽度，访问时去掉空格。<br>注意，保存的内容自身后面带有空格，也会被去掉，开发人员需要注意。</li>
<li>动态表。表中包含变长字段，记录不是定长的，优点是存储占用小。缺点是频繁更新删除记录会产生碎片，需要定期执行 optimize table 来优化，出问题时恢复较困难</li>
<li>压缩表。由myisampack工具创建，占据非常小的空间。</li>
</ul>
</li>
<li>InnoDB。提供了提交、回滚和崩溃恢复能力的事务安全。对比MyISAM引擎，写的效率较低，且会占用更多内存和硬盘空间。<ul>
<li>自动增长列。<code>alter table XX auto_increment=n</code> 修改初始值。<br>对于InnoDB，自动增长列必须是索引，在组合索引中必须是第一列。<br>但是对于MyISAM表，自动增长列可以是组合索引其他列。这样插入后，自动增长列是按照组合索引前面几列进行排序后递增的。</li>
<li>外键约束。MySQL支持外键的引擎只有InnoDB。实际上是在数据库层做了表关联，至少Rails中没看到使用。<br>创建索引时，能够指定更新父表时子表相应的操作。restrict限制在有子表关联的情况下父表不能更新，cascade表示父表更新删除时子表也更新删除，set null表示父表更新删除时子表相应字段设为null。</li>
<li>存储方式。存储表和索引有两种方式。<ul>
<li>共享表空间存储。表结构保存在.frm文件中，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件。</li>
<li>多表空间存储。表结构仍在.frm文件中，但是每个表的数据和索引单独保存在.ibd文件中。</li>
</ul>
</li>
</ul>
</li>
<li>memory。使用存在于内存中的数据来创建表。默认使用hash索引，也能指定btree。<br>每个memory表只对应一个磁盘文件，.frm文件。数据都在内存中，所以访问很快，但是服务关闭数据就丢失。<br>主要适用于内容变化不频繁的表。</li>
<li>merge。是一组MyISAM的组合，这些MyISAM表结构必须完全相同。<br>merge表本身没有数据，对其进行RUD操作都是对内部的MyISAM表的操作。插入是通过insert_method子句定义插入的表。drop操作删除merge的定义，对内部表无影响。<br>磁盘保留两个文件，.frm文件存储表定义，.mrg文件包含组合表信息。<br><code>create table payment_all (...) engine=merge union=(payment_1,payment_2) insert_method=last</code>。</li>
<li>TokuDB。第三方存储引擎，高写性能高压缩。<br>适用于，范围查询、存储量大的场景，如日志数据、历史数据等。<h3 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h3></li>
</ul>
</li>
<li>CHAR与VARCHAR。CHAR是定长的，处理速度较快，但是比较浪费空间。长度变化不大且对查询速度较高的可以使用CHAR。<br>但是随着版本升级，VARCHAR的性能也在提高。下面是不同存储引擎使用原则。<ul>
<li>InnoDB。建议使用VARCHAR。对于InnoDB表，内部行存储格式不区分定长变长（所有数据行使用指向该数据列值的头指针），因此使用CHAR不一定就性能好。而存储量角度看，使用VARCHAR更好。</li>
<li>MyISAM。建议使用定长代替可变长数据列。（没有理由）</li>
<li>memory。目前使用定长的数据行存储，也就是内部都是用CHAR类型处理。</li>
</ul>
</li>
<li>text与blob。blob能保存二进制数据，text只能保存文本数据。这里只是介绍两者常见的问题。<ul>
<li>性能问题，特别是执行了大量删除时。<br>删除操作会在表中留下大量空洞（内容删除但是存储空间没有被回收），所以需要定期执行 optimize table 进行碎片整理。</li>
<li>使用合成索引提高查询性能。<br>简单说，合成索引就是根据大文本字段的内容建立散列值（md5、sha1等），存储在一个新字段中。以后只要检索散列值，而不用搜索大文本字段，但适用于精确检索。</li>
<li>不必要的时候避免检索大型text或blob值。<br>select * 不是个很好的做法，除非能确定where子句只会找到所需数据行。</li>
<li>分离到单独的表中。<br>如果移出后，原表能转变成定长的数据行格式，那么就是有意义的。</li>
</ul>
</li>
<li>浮点数与定点数<br>浮点数会被四舍五入，而定点数其实是以字符串的形式存储的。<br>单精度浮点数误差会经常发生，精度要求较高的应用中（如货币）应该使用定点数表示和保存。<br>（编程中的浮点数比较，也是个常见的问题来源。应尽量进行范围比较，而不是断言等于或者不等于某个值）</li>
<li>日期类型选择<br>要记录年月日时分秒，且年代久远，最好使用 datetime，它的范围远大于 timestamp。<br>但是如果要表示时区，只有timestamp支持时区。<h3 id="字符集的选择"><a href="#字符集的选择" class="headerlink" title="字符集的选择"></a>字符集的选择</h3>以前遇到一个问题，需要支持emoji的话，必须使用 UTF-8 Unicode(utf8mb4)。<br>MySQL字符集包括字符集（character）和校对规则（collation）两个概念。一个是存储字符串的方式，一个是比较字符串的方式。<br>校对规则命名约定：以字符集名开始，包括语言名，以 <code>_ci</code>(大小写不敏感)， <code>_cs</code>(大小写敏感)，<code>_bin</code>(二元，比较是基于字符编码而与语言无关)结尾。</li>
<li>字符集和校对规则设置4级别：服务器级，数据库级，表级，字段级。<br>原则是不指定时，使用默认的或者继承上一级的。</li>
<li>修改字符集<br>alter操作修改字符集，但是这并没有更新已有记录的字符集，只是对新创建的有效。<br>第一步，导出表结构。<code>mysqldump -uroot -p -d dbname tb.sql</code><br>第二步，手工修改sql文件中的字符集为新的字符集<br>第三步，导出所有记录。<code>mysqldump -uroot -p --no-create-info ...</code>。打开文件，把 SET NAME latin1 修改为 SET NAME GBK。<br>第四步，创建表导入数据。<h3 id="索引的设计和使用"><a href="#索引的设计和使用" class="headerlink" title="索引的设计和使用"></a>索引的设计和使用</h3>不使用索引，MySQL将会扫描全表，直到找到相关行。<br>大多数索引类型 primary key, unique, index, fulltext等在btree中存储，空间列类型使用rtee。</li>
<li>MyISAM和InnoDB默认创建的是btree索引（B树，不是二叉树，是一种一般化的自平衡的二叉查找树）<br>MyISAM还支持全文索引。但是应用较少。因为MyISAM自身锁表不锁行，以及复杂全文查询支持差。<br>memory默认是hash索引。<br><code>explain select * from city where city= &#39;fuzhou&#39; \G</code>，使用explain语句进行查看SQL是否使用了索引。<code>\G</code> 后面不需要分号。</li>
<li>索引设计原则<br>搜索的索引列，不一定是要选择的列。最适合索引的列是出现在where子句中的列。<br>使用短索引。如果对字符串列进行索引，应该制定一个前缀长度，只要有可能就应该这么做。只对前10到20个字符进行索引能够节省大量空间，查询更快。</li>
<li>补充<br>有时候你创建了索引但是没有被使用，因为MySQL内部有个优化机制，它可能认为不使用更好。如果你想要强制使用，<code>force index(index_name)</code><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3>视图是一种虚拟表。相对普通表的优势：简单（视图是已经过滤好的结果集），安全（视图用户只能访问被允许访问的），数据独立（屏蔽表变化对视图的影响）<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> payment_view <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> city <span class="keyword">from</span> city <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>定义视图时，MySQL不允许from关键字后面有子查询。另外，使用了聚合函数、groupby、union、join，select中包含子查询 等的视图，不能更新。<br>with [cascaded|local] check option 决定是否允许更新数据使记录不再满足视图的条件。local只要满足本视图条件即可更新，cascaded必须满足所有针对该视图的视图的条件<br>查看视图， show tables 即可</p>
<h3 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h3><p>存储过程和函数是事先经过编译并存储在数据库的一段SQL的集合。调用存储过程和直接执行SQL的效果是一致的，好处是逻辑封装在数据库端。哪怕需要修改，对于调用者没有影响。<br>函数和存储过程的区别是函数必须有返回值，存储过程没有。存储过程的参数可以是in、out、inout，函数只能用in。<br>不过，它们能将数据处理在数据库服务器中间进行，减少数据的传输。但实际上大量复杂运算也会拖累数据库服务器，所以大量复杂运算还是尽量分摊到应用服务器中。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> film_in_stock(<span class="keyword">in</span> p_film_id <span class="built_in">int</span>, <span class="keyword">in</span> p_store_id <span class="built_in">int</span>, <span class="keyword">out</span> p_film_count <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">read</span> <span class="keyword">sql</span> <span class="keyword">data</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> inventory_id <span class="keyword">from</span> inventory <span class="keyword">where</span> film_id = p_film_id <span class="keyword">and</span> store_id = p_store_id <span class="keyword">and</span> inventory_in_stock(inventory_id);</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">found_rows</span> <span class="keyword">into</span> p_film_count;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> film_in_stock(<span class="number">2</span>, <span class="number">2</span>, @a)</span><br></pre></td></tr></table></figure></p>
<p>通常执行创建之前，会通过delimiter命令将语句结束符修改为其他符号，这里是 $$。这样过程和函数中的 ; 就不被MySQL解释成语句结束而提示错误。创建完毕后再改回来。<br>characteristic特征值</p>
<ul>
<li>{contains sql | no sql | reads sql data | modifies sql data }<br>子程序包含sql，不包含sql，只包含读数据的语句，包含写语句。一般只是提供给服务器，并没有约束效力。</li>
<li>sql security {definer | invoker} 指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认definer。<br>子程序中，还可以使用变量，条件（处理异常），光标（循环结果集），流程控制，<ul>
<li>MySQL定时任务：事件调度器，将数据库按自定义的时间周期触发操作，可以理解为时间触发器，类似crontab。<br>调度器创建后需手动开启才能生效。非常适合定时清空临时表或日志表。<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3>触发器是与表有关的数据库对象，在满足定义条件时触发，执行触发器中定义的语句集合。协助应用在数据库端确保数据完整性。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> ins_film <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> film <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> film_text(film_id, title, description) <span class="keyword">values</span> (new.film_id, new.title, new.description);</span><br><span class="line"><span class="keyword">END</span>; $$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>使用old，new别名来引用触发器中发生变化的记录内容。<br>注意：包含insert或update的SQL，并不只是单纯触发insert或update相关的触发器。<br>比如对于有重复记录需要进行update的insert，<code>insert...on duplicate key update...</code>，按顺序触发 before insert, before update, after update。</p>
<h3 id="事务控制和锁定语句"><a href="#事务控制和锁定语句" class="headerlink" title="事务控制和锁定语句"></a>事务控制和锁定语句</h3><ul>
<li>lock tables 与 unlock table。<br><code>lock table film_text read;</code>, 其他线程不能读；<code>unlock tabls;</code>，其他线程获得锁。</li>
<li>事务。<br>所谓事务，不提交，行记录是无法被其他session查询到的。默认情况下，MySQL是自动提交Autocommit的<br>start transaction 或者 begin 开始一项事务。commit 和 rollback 提交和回滚事务。savepoint<br>补充，MySQL还支持分布式事务，只有InnoDB支持。但是服务器异常重启、客户端连接异常中止，都可能导致事务不完整（prepare状态的分支事务没有写到binlog），总之不推荐。<h3 id="SQL安全问题"><a href="#SQL安全问题" class="headerlink" title="SQL安全问题"></a>SQL安全问题</h3>SQL注入：将用户输入，插入到实际的SQL中执行。<br>办法：进行各种API对特殊字符进行转换。<h3 id="SQL-MODE-及相关问题"><a href="#SQL-MODE-及相关问题" class="headerlink" title="SQL MODE 及相关问题"></a>SQL MODE 及相关问题</h3>SQL MODE的严格模式，提供了很好的数据校验功能。查看SQL MODE，使用 <code>select @@sql_mode</code>。<br>指定 <code>set sql_mode=&#39;ansi&#39;</code>可以获得对应组合模式。常用mode值：ANSI（等同于多个小模式的组合模式）、STRICT_TRANS_TABLES、TRADITIONAL。<br>另外数据迁移时，还有 ORACLE、DB2、POSTGRESQL 这些模式组合，这样导出的数据更容易导入异构的目标数据库。<h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3></li>
<li>额外发现：MySQL的元数据库 <strong>information_schema</strong>，有个partitions表（其实很多信息都在这个数据库中，包括支持的引擎、字符集、processlist等很多知识）。<br>这个表中，能发现到不分区的表其实被看做一个默认分区。能看到表中的行数、数据大小（单位byte）、索引大小等信息。</li>
<li><p>MySQL支持大部分引擎（InnoDB、MyISAM、memory等）创建分区表。不能使用主键/唯一键之外的字段分区（除非没有主键/唯一键）。</p>
<ul>
<li>NULL的处理。Range中被看做最小值，Hash/Key中被看做0，List中Null必须出现在枚举列表中。<br>主要四种分区类型，Range、List、Hash、Key。前三种要求分区键必须是INT类型，或者通过表达式返回INT。Key分区支持其他键。</li>
<li><p>Range。原本只支持整数列，但是用函数转换也可以。但是如果查询不使用函数，就无法利用分区特性提高性能。<br>适用于：删除过期数据，alter table emp drop partition p0 即可删除分区及其数据；经常运行包含分区键的查询，能够确定只有哪些分区要扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(...)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span> (<span class="keyword">year</span>(created_at)) (</span><br><span class="line">  <span class="keyword">partition</span> p0 <span class="keyword">value</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="string">'1992-01-02'</span>),</span><br><span class="line">  <span class="keyword">partition</span> p0 <span class="keyword">value</span> <span class="keyword">less</span> <span class="keyword">than</span> maxvalue <span class="comment">-- 不设上限</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>List。类似Range，但是是离散值分区。所有分区键值必须在可枚举的集合中，如 <code>partition p0 values in (2, 4)</code>。</p>
</li>
<li>Columns。是5.5新引入的分区类型，解决了Range、List只支持整数分区，从而导致额外的函数计算的问题。<br>细分为 Range Column和List Column，支持整数、日期、字符串，不支持表达式作为分区键。<br>Column 另一个亮点是，支持多列分区，如 <code>partition by range columns(a,b)</code>。实际插入的时候，会先看a是否小于界定值，如果a等于，再看b是否小于界定值。</li>
<li>Hash。分区键必须是整数。<br>支持两种分区，常规hash分区和linear hash分区。前者使用取模算法，后者使用线性的2的幂的运算法则（线性哈希，网上搜的也看不太懂）。<ul>
<li>普通hash分区。<code>partition by hash(&lt;expr&gt;) partitions &lt;num&gt;</code><br>原理比较简单，就是把分区键对分区的数目进行取模。<br>主要用来分散热点读，使数据在分区中尽可能平均分布。问题：一旦要增加分区或合并分区时，大部分数据都要重新计算分区。</li>
<li>线性hash分区。<code>partition by linear hash(&lt;expr&gt;) partition &lt;num&gt;</code><br>原理中有个 <code>234 &amp; (4-1) = 2</code> 这个运算看不懂，网上搜的东西就更难看懂了。优势是分区维护时MySQL处理更加迅速，缺点是数据分布不太均衡。</li>
</ul>
</li>
<li>Key。类似Hash，但不能使用表达式，并且分区键除了Text和Blob以外都支持。</li>
</ul>
</li>
<li>常用SQL<br>查看记录在哪个分区中 <code>explain partition select * from emp where store_id=234\G</code>。<br>查看各个分区中聚合参数。<br><code>select partition_name part, partition_expression expr, partition_description desc, table_rows from information_schema.partitions where table_schema=schema() and table_name=&#39;emp&#39;</code></li>
<li>分区管理<ul>
<li>Range/List。删除操作之前提到过。<br>增加分区，<code>alter table emp add partition (partition p4 values less than (2013))</code>。新增Range分区，必须在分区最大端往更大；新增List分区，不能包含现有值。<br>重新分区，<code>alter table emp reorganize partition p1,p2 into (partition p1 values less than (2015))</code>。重新定义用来拆分和合并，据说数据不丢失，没试过。</li>
<li>Hash/Key。<br>减少分区，<code>alter table emp coalesce partition 2</code>。减少为2个分区，这个语句不能用来增加分区。<br>增加分区，<code>alter table emp add partition 8</code>。这是增加8个分区，不是增加到8个，所以现在有10个分区。</li>
</ul>
</li>
</ul>
<h2 id="第三部分-优化篇"><a href="#第三部分-优化篇" class="headerlink" title="第三部分 优化篇"></a>第三部分 优化篇</h2><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><ul>
<li><p>优化SQL的一般步骤</p>
<ul>
<li>show status 查看执行频率。<br>如 <code>show global status like &#39;Com_%&#39;</code> 查看数据库启动后语句的执行统计结果，<code>show status like &#39;Slow_queries&#39;</code> 查看当前session慢查询次数。</li>
<li>定位执行效率低的SQL语句。<br>一般两种方式：查看慢查询日志，以及 <code>show processlist</code> 查看当前线程状态。</li>
<li>explain 分析低效SQL执行计划<ul>
<li>explain一个SQL语句后，会有个表展示相关信息<ul>
<li>select type。表示select类型，常见的有 simple（简单表，不用表连接或子查询）、primary（主查询）、UNION（union中第二个开始的查询）、subquery（子查询第一个select）</li>
<li>type。MySQL找到所需行的方式，或叫访问类型。效率 all &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const,system &lt; NULL。<ul>
<li>type=all。遍历全表</li>
<li>type=index。遍历整个索引</li>
<li>type=range。索引范围扫描，常见于 &lt;、&gt;、between等操作符</li>
<li>type=ref。使用非唯一索引或者唯一索引的前缀扫描，返回匹配某个单独值的记录行。也常见于join操作中。</li>
<li>type=eq_ref。使用唯一索引，也就是表中只有一条记录匹配。常见于多表连接中使用主键或unique index作为关联条件</li>
<li>type=const/system。单表中最多一个匹配行，这一行的其他列值可以被优化器当做常量来处理。如根据主键或唯一索引查询的是const，再从其中检索时是system。</li>
<li>type=null。不用访问表或者索引</li>
</ul>
</li>
<li>possible_keys。查询时可能用的索引</li>
<li>key。实际使用的索引。</li>
<li>key_len。使用到的索引长度</li>
<li>Extra。额外信息，这个也很有用，下一节索引会提到。</li>
</ul>
</li>
<li>explain extended 加上 show warnings 查看SQL真正执行前优化器做了哪些改写。<br><code>explain extended select ...</code> <code>show warnings \G</code>。</li>
</ul>
</li>
<li><p>show profile 分析SQL，定位问题<br><code>select @@have_profiling</code> 查看是否支持profile，<code>select @@profiling</code> 查看开闭状态，<code>set profiling=1</code> 开启。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;            <span class="comment">-- 查看SQL的 Query_Id。</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>; <span class="comment">-- 查看所需 Query_Id的SQL的执行过程中线程的每个状态和消耗时间。</span></span><br><span class="line"><span class="comment">-- 上面这里常见的是 sending data 状态最耗时。它表示开始访问数据行并把结果返回客户端，而不仅仅是返回结果给客户段，往往需要大量磁盘读取操作。</span></span><br><span class="line"><span class="comment">-- 此时也可以，通过查询 information_schema.profiling 表，并按照消耗时间倒序排列进行查看。</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">4</span>; <span class="comment">-- 支持进一步选择 all、cpu、block io、context switch、page fault等明细类型查看</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 trace 分析优化器如何选择执行计划<br><code>set optimizer_trace=&quot;enabled=on&quot;, end_markers_in_json=on</code> 打开trace，设置格式为json<br><code>set optimizer_trace_max_mem_size=1000000</code> 设置最大能使用的内存大小，避免不能完整显示。（不过书中没有对trace文件内容做详细说明）</p>
</li>
<li>确认问题并采取优化措施<br>比如全表扫描的话，就创建索引</li>
</ul>
</li>
<li>索引问题（指B-Tree索引）<br>带索引的查询可以理解为有两类，第一类在索引中查询，第二类从索引回表查询。<ul>
<li>索引能够使用的典型场景<ul>
<li>匹配全值。查询时，对索引中所有列都指定具体值</li>
<li>匹配值的范围查询。对索引的值进行范围查找<br><code>explain select * from rental where customer_id &gt;= 373 and customer_id &lt; 400 \G</code>。注意到 Extra列为 Using Where，表示还需要根据索引回表查询数据</li>
<li>匹配最左（leftmost）前缀。仅仅使用索引最左边的列进行查找。————最重要的原则<br>比如 col1 + col2 + col3 字段的联合索引，能够被包含 col1、(col1 + col2)、(col1+col2+col3)的等值查询利用到，可是不能被 col2、(col2+col3)等值查询利用</li>
<li>仅仅对索引进行查询。查询的列都在索引的字段中时，甚至都不用回表。<br><code>explain select last_update from payment where customer_id=12</code>。last_update字段也在索引中。注意到 Extra列为 Using index，意味着只要访问索引即可获得所需数据。</li>
<li>匹配列前缀。仅仅使用索引中第一列的开头一部分<br><code>explain select title from film_text where title like &#39;African%&#39;</code>。</li>
<li>索引匹配部分精确而其他部分范围匹配。<br><code>explain select inventory_id from rental where date = &#39;2006-12-23&#39; and customer_id &gt;= 373 and customer_id &lt; 400 \G</code></li>
<li>下面是补充部分<ul>
<li>列名是索引，<code>where &lt;column&gt; is null</code> 也会使用索引。区别于Oracle。</li>
<li>Index Condition Pushdown特性，部分情况下的条件过滤下放到存储引擎。简单说，根据复合索引回表获取记录后，再过滤一次的操作，能够被优化到，不再进行第二次过滤。</li>
</ul>
</li>
</ul>
</li>
<li>存在索引但不能被使用的典型场景<ul>
<li>以%开头的like查询。<br>比如 <code>explain select * from actor where last_name like &#39;%NI%&#39; \G</code>。<br>如果我们有个索引存储last_name和主键actor_id，可以首先扫描索引获得满足 last_name like ‘%NI%’ 条件的主键actor_id列表，再根据主键回表检索记录，避开全表扫描<br><code>explain select * from (select actor_id from actor where last_name like &#39;%NI%&#39;)a, actor b where a.actor_id = b.actor_id</code>。<br>这里的第一次查询，我们使用了“仅仅对索引进行查询”，所以条件里面虽然有索引列的非开头部分，也能使用索引进行查询。</li>
<li>数据类型隐式转换时。<br>比如对于字符串类型的字段，你的条件是数值类型，将不会使用索引。（这个感觉比较少见，更像是编程错误）</li>
<li>复合索引时，查询条件不包含索引列最左部分。也就是不满足最左原则leftmost，之前提过了</li>
<li>MySQL估计使用索引比全表扫描慢时。<br>通过trace，可以看到优化器的选择过程，如果使用索引代价cost比扫描全表高，将不会使用</li>
<li>用or分割开的条件，如果or前的条件有索引，后面的列没有索引。<br>or后面列没有索引，肯定要全表扫描。在存在全表扫描的情况下，就没必要多一次索引扫描了。</li>
</ul>
</li>
<li>查看索引使用情况<br><code>show global status like &#39;Handler_read%&#39;</code>。<br>Handler_read_key表示一个行被索引值读的次数，越高越好；Handler_read_rnd_next表示数据文件中读下一行的请求数，表扫描越多，值越高，意味着查询低效。</li>
</ul>
</li>
<li>简单优化方法<ul>
<li>分析表和检查表<br><code>analyze table &lt;table&gt;</code> 用于分析和存储表的关键字分布，分析结果使系统得到准确的统计信息，使SQL生成正确的执行计划。如果感觉执行计划生成不是预期，分析表可能可以解决<br><code>check table &lt;table&gt;</code> 用于检查表是否有错误。</li>
<li>定期优化表<br><code>analyze table &lt;table&gt;</code>。常用于删除大量数据后，合并空间碎片，前面提过。</li>
</ul>
</li>
<li>常用SQL优化<ul>
<li>大批量插入数据<ul>
<li>MyISAM<br><code>alter table tbl_name disable keys</code>，导入到非空MyISAM表前，先关闭非唯一索引的更新，之后再 enable。（导入空表，默认就是先导入后创建索引的，所以不需要设置）</li>
<li>InnoDB<br>InnoDB类型表是按照主键顺序保存的，所以将导入的数据按照主键顺序排列，能够提高导入效率<br><code>set unique_checks=0</code>，导入前，关闭唯一性校验，之后再打开。<br>如果使用自动提交的方式，导入前，<code>set autocommit=0</code> 关闭自动提交，之后再打开。</li>
</ul>
</li>
<li>优化insert语句<br>同一用户插入多行，尽量使用一次插入多值，<code>insert into test values(1,2), (1,3), (1,4)...</code><br>不同用户插入多行，可以用insert delayed。含义是insert语句立刻执行，其实数据都被放在内存队列中，没有写入磁盘；low_priority相反，在所有其他用户读写完成后才插入<br>索引文件和数据文件在不同磁盘上存放（建表时）<br>批量插入MyISAM时，增加 bulk_insert_buffer_size 变量值<br>从文本装载时，load data infile，比使用许多insert语句快得多。</li>
<li>优化order by语句<br>MySQL有两种排序方式，<ul>
<li>一种索引直接返回，<code>explain select customer_id from customer order by store_id \G</code>。</li>
<li>凡是非索引直接返回的都叫Filesort排序。<br>Filesort不代表通过磁盘进行排序，而是说明进行了一个排序操作，算法马上说明。<br>两种算法：<ul>
<li>两次扫描。第一次取出排序字段和行指针信息，之后在sort buffer中排序（不够的话，在临时表中存储排序结果），完成后回表读取记录。效率低，但是占用内存小</li>
<li>一次扫描。一次取出所有满足条件行的所有字段，然后在sort buffer中排序。效率高，但是占内存。<br><code>max_length_for_sort_data</code> 和query语句取出的字段总大小比较，如果max_length更大，就用效率更高的第二种算法。但不能设置过大，否则造成CPU利用率过低和磁盘IO过高。<br>适当增大 <code>sort_buffer_size</code>，让排序在内存中完成，而不是通过创建临时表在文件中完成。但也不能设置过大，否则导致服务器SWAP严重（？）<br>select 具体字段名称，可以减少排序区的使用。<br>优化目标：减少额外排序，索引直接返回有序数据。where条件和order by使用相同索引，且order by的顺序和索引顺序相同，且order by的字段都是升序或降序。否则肯定需要Filesort</li>
<li>对索引使用的影响。（使用Filesort与不使用索引并不严格相关）<br>order by中字段混合升序降序，where与order by使用不同索引，order by中使用不同关键字：都会导致不使用索引。<br>order by中字段属于同一索引且都是同序，where与order by使用相同索引：都会使用索引。</li>
</ul>
</li>
</ul>
</li>
<li>优化group by语句<br>默认情况下，MySQL对所有group by字段进行排序，与order by字段差不多。不过如果想要避免排序结果的消耗，可以 order by null 禁止排序。</li>
<li>优化嵌套查询<br>子查询技术，可以用select语句创建一个单列的查询结果，作为过滤条件用在另一个查询中。<br>有些情况下，可以使用join替代。join之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两步的查询工作。</li>
<li>优化OR条件<br>OR前后的条件列都必须用到索引，OR前后使用同一复合索引是不行的。执行计划中能看到实际是对OR前后分别查询再UNION。</li>
<li>优化分页查询<br>常见的头痛场景是，<code>limit 1000,20</code>。排序出前1020条记录后仅需返回最后20条，前面1000条都被舍弃，代价很高。<ul>
<li>第一种思路：在索引上完成排序分页，最后根据主键关联回表查询所需其他列的内容<br><code>explain select film_id, description from film order by title limit 50,5 \G</code><br><code>explain select a.film_id, a.description from film inner join (select film_id from film order by title limit 50,5)b on a.film_id=b.film_id \G</code></li>
<li>第二种思路：翻页时增加一个参数，用来记录上一页最后一行的id。这样只要找到比这个id大（或者小）的几个即可。<br>将<code>limit m,n</code> 转换成了 <code>limit n</code> 的查询。适合排序字段不会出现重复值的情况</li>
</ul>
</li>
<li>使用SQL提示<br>都是写在表明之后，如 <code>select * from rental force index (idx_fk_inventory_id) where inventory_id &gt; 1 \G</code><ul>
<li>use index。提供希望MySQL参考的索引列表</li>
<li>ignore index。忽略索引</li>
<li>force index。强制使用索引。<h3 id="优化数据库对象"><a href="#优化数据库对象" class="headerlink" title="优化数据库对象"></a>优化数据库对象</h3></li>
</ul>
</li>
</ul>
</li>
<li>优化表数据类型。<br><code>select * from tbl_name procedure analyse()</code>。分析当前应用表，并查看优化建议。</li>
<li>拆分表。这里提到的是MyISAM，InnoDB应该一样。<ul>
<li>垂直拆分。主码和一些列放到一个表，主码和另外的列放到另一个表中。常用于，某些列常用，另一些不常用。数据行变小，一个数据页能存放更多数据，减少IO。缺点是查询所有数据时需要join操作。</li>
<li>水平拆分。多列放到两个独立表中。常用于，表很大减少数据量，本身就有一定独立性如不同月份的话单。</li>
</ul>
</li>
<li>逆规范化<br>规范化越高，产生的关系就越多，导致的就是表之间连接操作越频繁。所以对于查询较多的应用，需要根据实际情况进行逆规范化设计提高性能。<br>（增加冗余列操作跟垂直拆分其实恰好相反。使用情景也相反，垂直拆分是表中不常用的字段过多，逆规范化是表中缺失少量字段需要连表）<br>常用的操作有，增加冗余列，增加派生列（计算生成），重新组表（经常要连表干脆组合起来），分割表（就是拆分）<br>逆规范化技术需要维护数据完整性。常见的有在应用逻辑实现，使用触发器等。<h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3></li>
<li>MyISAM表锁<ul>
<li>查询表级锁争用情况。 <code>show status like &#39;table_lock%&#39;</code>。</li>
<li>锁模式。两种：表共享读锁，表独占写锁。读操作与写操作之间、以及写操作之间是串行的。</li>
<li>如何加表锁。<br>MyISAM执行查询前，自动给涉及表加读锁；执行更新操作（增删改）前，自动加写锁。一般不用用户显式地lock table。（书中主要是为了方便说明）<br>显式lock tables时，当前线程只能访问显式加锁的这些表，不能访问未加锁表。MyISAM必须一次获得所有涉及表的锁，所以不会出现死锁。</li>
<li>并发插入。<br>一定条件下，MyISAM也支持查询和插入操作并发进行。加锁时带上local选项，如 <code>lock tabls film read local;</code><br>该存储引擎系统变量 concurrent_insert 用于控制。设为0，不允许并发插入；设为1，表没有空洞时允许另一进程在表尾插入记录；设为2，不管有没有空洞都允许在表尾并发插入</li>
<li>锁调度。<br>MySQL认为写请求比读请求重要，所以写进程优先获得写锁，读进程不要写锁只要读锁也在后面。所以MyISAM表不太适合大量更新和查询操作应用，读操作可能永远阻塞。<br>通过设置调节调度行为：<code>set low_priority_updates=1</code> 降低该连接的更新请求优先级；指定增删改语句的low_priority属性，降低语句优先级。</li>
</ul>
</li>
<li><p>InnoDB表锁</p>
<ul>
<li>背景知识<ul>
<li>事务是由一组SQL语句组成的逻辑处理单元，具有以下ACID属性<ul>
<li>原子性Atomicity。事务是一个原子操作单元，对数据的修改，要么都执行，要么都不执行；</li>
<li>一致性Consistent。事务开始和完成时，数据必须保证一致状态。意味着事务过程中，不能有其他事务修改数据</li>
<li>隔离性Isolation。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的环境中执行。事务过程中，中间状态对外部是不可见的，反之亦然。</li>
<li>持久性Duration。事务完成之后，对于数据的修改是永久性的，即使系统故障也能保持。</li>
</ul>
</li>
<li>并发事务带来的问题<ul>
<li>更新丢失。多个事务选择同一行并进行更新时，每个事务都不知道其他事务的存在，就会发生更新丢失——最后的更新覆盖其他事务的更新</li>
<li>脏读。一个事务正在对一行进行修改，事务完成提交之前，这行数据就处于不一致状态。这时如果另一个事务来读取同一行，如果不加控制，就读取了脏数据。</li>
<li>不可重复读。一个事务过程中，两次读同样的数据，却发现数据已经发生改变甚至被删除</li>
<li>幻读。一个事务过程中，两次用同样的条件进行查询，第二次发现有其他事务插入的符合条件的新数据。</li>
</ul>
</li>
<li>事务隔离级别<ul>
<li>解决问题，防止更新丢失是应用的责任（数据库事务具有隔离性）；而另外三种都是数据库读一致性问题，数据库通过提供事务隔离机制来解决，一般有两种方式<ul>
<li>读取数据前，对其加锁，防止其他事务对数据进行修改</li>
<li>不加锁，通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照提供一定级别（语句或事务级）的一致性读取。叫做数据多版本并发控制MVCC。</li>
</ul>
</li>
<li>隔离与并发的矛盾，SQL92 定义了4个事务隔离级别。分别是上述三个一致性问题的反映，<br>未提交读，全部都会发生；已提交读，脏读不发生；可重复读，只有幻读发生；可序列化，全部不发生。<br>MySQL中查看隔离级别，<code>select @@tx_isolation;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>获取InnoDB行锁争用情况。<code>show status like &#39;innodb_row_locks%&#39;</code>。如果比较严重，则需要查看详细</p>
<ul>
<li>查看information_schema.innodb_locks表。</li>
<li>设置InnoDB Monitors。按下面操作，默认15秒向日志中记录监控内容，完成后务必删除监控表。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> innodb_monitors(a <span class="built_in">INT</span>) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span> \G</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> innodb_monitors;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>行锁模式和加锁方法</p>
<ul>
<li>行锁<br>两种行锁。共享锁S：组织其他事务获得相同数据集；排它锁X：阻止其他事务取得相同数据集的读锁和写锁。</li>
<li>意向锁。允许行锁与表锁共存，意向锁都是表锁。<br>两种意向锁。意向共享锁IS：事务在给行加S锁前必须获得表的IS锁；IX锁同样。<br>意向锁是自动加的：对于增删改语句，InnoDB自动加涉及数据集的X锁；对于查询语句，不加任何锁。<br>也可以显式地给数据集加锁：S锁，<code>select * from tbl_name where... lock in share mode</code>；X锁，<code>select * from tbl_name where... for update</code>。<br>如果 <code>select * in share mode</code>获得共享锁，如果还要进行更新操作，则很容易造成死锁。要进行更新操作时，务必使用排它锁。（？意向锁是自动加的，但是显式加锁并不常见）</li>
</ul>
</li>
<li>InnoDB行锁实现方式。<br>InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，将通过隐藏的聚簇索引来对记录进行加锁。<ul>
<li>如果不通过索引条件检索数据，那么InnoDB将对表中所有记录进行加锁，效果等同于表锁。</li>
<li>访问不同行数据，但是如果使用相同索引键（查询使用的其他键没有索引），是会出现锁冲突的。</li>
<li>如果使用不同索引，但是访问相同数据集，前面查询的排它锁没有释放，后面的查询也无法获得数据。（只要使用索引，通常就是行锁而不锁表；访问相同的数据，肯定是被锁的。）</li>
<li>注意，分析锁冲突的时候，记得检查SQL的执行计划。如果MySQL认为不需要使用索引，也将锁表。</li>
</ul>
</li>
<li>Next-Key锁。<br>使用范围条件检索并请求锁时，InnoDB会给键值在条件范围内但并不存在的记录（Gap）加锁，这个锁机制叫做Next-Key锁。作用是防止幻读。<br>但是会阻塞范围内的并发插入，所以在实际应用中尽量使用相等条件来访问更新数据。（相等条件请求给一个不存在的记录加锁，也会使用Next-Key锁）</li>
<li>恢复和复制的需要，对InnoDB锁机制的影响<br>MySQL通过binlog记录执行成功的增改删等更新数据的SQL语句，并由此实现数据库的恢复和主从复制。有三种日志格式，基于语句的日志格式SBL，基于行的RBL和混合格式。<ul>
<li>对基于语句日志格式SBL而言，要求一个事务未提交之前，并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。这就是InnoDB需要使用Next-Key锁的原因。</li>
<li>对于<code>insert into target_tbl select * from source_tbl where...</code> 和 <code>create table new_tbl ...select * from source_tbl where...</code><br>这两个语句，只是简单读source_tbl表的数据，相当于一个普通的select。InnoDB有多版本数据，对普通select一致性地读，不加任何锁；但在这里却给source_tab加共享锁。<br>因为在语句执行过程中，其他事务对source_tab做了更新操作，如果不加锁，就可能导致数据恢复的结果错误。（binlog中保存事务顺序不对）<br>所以推荐的不加锁做法是，select into outfile 和 load data infile的语句合用；或者使用基于行的binlog格式和基于行的复制。</li>
</ul>
</li>
<li>InnoDB使用表锁<br>特殊事务中，考虑表级锁：事务需要更新大部分或全部数据，事务执行效率低；事务涉及多个表比较复杂，容易引起死锁，造成大量事务回滚。<ul>
<li>表锁不是由InnoDB存储引擎层控制的，而是由其上一层MySQL Server负责，仅当 autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB才能识别表级锁的死锁。</li>
<li>lock tables 事务结束时，不要 unlock tables释放表锁，因为它会隐含地提交事务；而commit或rollback不能释放表锁。两个都是不可省略的，unlock tables在后。</li>
</ul>
</li>
<li>关于死锁<br>MyISAM总是一次获得所需全部锁，要么全部满足，要么等待，不会出现死锁。而InnoDB，除单个SQL组成的事务外，锁是逐步获得的，所以可能发生死锁。<br>比如两个事务，都需要获得对方持有的排它锁才能完成事务，就是典型的死锁。设置锁等待超时参数 innodb_lock_waite_timeout 解决死锁问题，以及高并发下的性能问题。<br>一般来说，死锁都是应用设计的问题，下面介绍避免死锁的常用方法<ul>
<li>应用中，如果不同程序并发存取多个表，应尽量约定以相同的顺序来访问表。（比如刚才的典型死锁，就是互相需求对方所执的锁）</li>
<li>程序以批量方式处理数据的时候，尽量事先对数据进行排序，保证每个线程按固定顺序来处理记录。（跟上面这条差不多）</li>
<li>事务中更新记录，直接申请足够高级别的锁，即排它锁。而不应先申请共享锁，更新时再申请排它锁。因为此时其他事务可能又获得了相同记录的共享锁，造成锁冲突甚至死锁。</li>
<li>repeated-read隔离级别下，两线程同时对相同记录加排它锁，在没有符合该条件记录情况下，两个线程都会加锁成功。这时如果两线程都试图插入新记录，就会死锁。隔离界别改为read commited 可解。</li>
<li>read-commited隔离级别下，两线程都执行加排它锁，判断是否存在条件的记录，如果没有就插入记录。此时只有一个能成功，另一个锁等待，等第1个提交之后，第2个线程会主键重复出错，但它会获得一个排它锁。这时第3个线程申请排他锁也会出现死锁。<br>这时应先做插入，再捕获主键重复异常，或者遇到主键重复异常时，总是rollback释放排它锁。<br>最后，如果出现死锁，<code>show innodb status</code> 可以查看最后一个死锁的产生原因。<h3 id="优化MySQL-Server"><a href="#优化MySQL-Server" class="headerlink" title="优化MySQL Server"></a>优化MySQL Server</h3></li>
</ul>
</li>
</ul>
</li>
<li>内存管理及优化<ul>
<li>MyISAM<br>MyISAM存储引擎使用key buffer缓存索引块；而对于数据块，MySQL没有特别的缓存机制，完全依赖于系统的IO缓存。<ul>
<li>key_buffer_size。决定MyISAM索引块缓存区大小</li>
<li>使用多个索引缓存。key buffer是共享的，所以增大并不能解决多session的竞争。<br><code>set global hot_cache.key_buffer_size=128*1024</code> 新建索引缓存（设为0即是删除）。<code>cache index sales in hot_cache</code> 指定sales表的索引缓存，否则使用默认。</li>
<li>调整“中点插入策略”。<br>默认情况下，MySQL使用LRU（Least Recently Used）策略来选择要淘汰的索引数据块。但是这个算法不精细，某些情况下会导致真正的热块被淘汰。<br>所以这里引入中点插入策略，其关键是把LRU链分成两部分。通过 key_cache_division_limit 来控制。默认是100，也就是不启用此策略；设为70，也就是用30%缓存来cache最热索引</li>
</ul>
</li>
<li>InnoDB内存优化<br>InnoDB用一块内存区做IO缓存池，不仅缓存InnoDB索引块，也用来缓存InnoDB数据块。内部，缓存池逻辑上由free list、flush list和LRU list构成。<br>free list是空闲缓存列表，flush list是需要刷新到磁盘的缓存块列表，LRU list是正在使用的缓存块，是 InnoDB buffer pool 的核心。<br>优化性能：可以通过调整InnoDB buffer pool大小、改变中点插入策略分配比例、控制脏缓存的刷新活动、使用多个InnoDB缓存池等方法来。<ul>
<li>innodb_buffer_pool_size。表数据和索引数据的最大缓存区大小。可以将80%物理内存分配过去，但是不能设置过大导致页交换（？待查询）</li>
<li>innodb_old_blocks_pct，控制中点插入策略old sublist的分配比例。可通过show variables like查看。</li>
<li>innodb_old_blocks_time，决定了缓存数据块由old sublist转移到young sublist的快慢。</li>
<li>innodb_buffer_pool_instance，调整缓存池数量，将缓存池大小平均分配给这么多个缓存池，减少内部争用。</li>
<li>缓存池中数据停留时间尽可能长，从而减少磁盘IO次数，磁盘IO是数据库系统的最主要瓶颈。通过延迟缓存刷新来减少IO系统的压力，缓存池刷新快慢主要取决于下面两个参数<ul>
<li>inndb_max_dirty_pages_pct，控制了缓存池脏页的最大比例</li>
<li>innodb_io_capacity，磁盘IO能力</li>
</ul>
</li>
<li>InnoDB doublewrite。MySQL数据页与操作系统数据页大小不一致，无法保证InnoDB缓存页被完整一致地刷新到磁盘。双写开启对性能影响不大，但如果对一致性要求不高，也可以关闭。</li>
</ul>
</li>
</ul>
</li>
<li>InnoDB log机制及优化<br>支持事务的数据库系统，内部使用redo log来保证事务的ACID。<br><a href="http://www.cnblogs.com/liuhao/p/3714012.html" target="_blank" rel="noopener">MySQL redo log及recover过程浅析</a><br>更新数据时内部流程：数据读入缓存池，相关记录加独占锁；将UNDO信息写入undo表空间的回滚字段；更改缓存页中数据，将更新记录写入redo buffer；提交时将redo buffer中更新记录刷新到InnoDB redo log file中，然后释放独占锁；最后后台IO线程根据需要择机将缓存中更新过的数据刷新到磁盘文件中。<br>（<code>show engine innodb status</code> 查看日志写入情况。LSN（log sequence number）日志序列号，老的LSN = 新的LSN + 写入的日志大小）<br>优化性能：除缓存池外，InnoDB log buffer大小、redo日志文件大小以及 innodb_flush_log_at_trx_commit（提交时刷新到log file方式）等参数设置<ul>
<li>innodb_flush_log_at_trx_commit。设为0，InnoDB每秒触发一次缓存日志回写磁盘操作，并调用fsync刷新IO缓存；设为1，事务提交时立刻回写刷新；设为2，立即回写但不刷新IO。<br>默认是1，最安全但性能最差。修改为0，如果数据库崩溃，最后1秒重做日志丢失，最不安全；修改为2，如果崩溃，数据不会丢失，安全性能的折中。</li>
<li>innodb_log_file_size。一个日志文件写满之后，InnoDB会切换到另一个日志文件，切换时触发数据库检查点，导致缓存脏页小批量刷新，明显降低数据库性能。<br>一般来说每半小时写满一个日志文件比较合适。书中给了两种估算方法，其中一个是通过information_schema.global_status表的innodb_os_log_written来计算。</li>
<li>innodb_log_buffer_size，重做日志缓存池</li>
</ul>
</li>
<li>MySQL并发相关参数<br>max_connections，提高并发连接（connection_errors_max_connection）；table_open_cache，控制所有SQL执行线程可打开表缓存的数量<h3 id="磁盘IO问题"><a href="#磁盘IO问题" class="headerlink" title="磁盘IO问题"></a>磁盘IO问题</h3>前面提到的SQL优化、数据库对象优化、数据库参数优化、应用程序优化等，通过减少或延缓磁盘读写来减轻IO压力。这里从磁盘阵列、符号链接、裸设备等底层技术提高磁盘IO能力</li>
<li>磁盘阵列 RAID，按照一定策略将数据分布到若干物理磁盘上。</li>
<li>虚拟文件卷或软RAID，操作系统模拟了一些RAID特性，改善性能和可靠性。</li>
<li>符号链接 Symbolic Links。利用操作系统符号链接（ln -s），将不同数据库、表或索引的datadir指向不同物理磁盘，从而分布磁盘IO。</li>
<li>IO调度算法。操作系统对于磁盘IO请求，有四种调度算法。MySQL数据库环境设为Deadline算法更稳定；对于SSD设备，采用NOOP或者Deadline更好。<h3 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h3></li>
<li>使用连接池。不是直接访问数据库，而是从这个连接池中获取连接来使用。</li>
<li>减少对SQL的访问：避免重复检索。增加cache层。</li>
<li>负载均衡<ul>
<li>利用MySQL的主从复制，可以有效分流更新和查询操作。具体是主服务器承担更新，多台从服务器承担查询，主从之间通过复制实现数据同步。</li>
<li>分布式数据库架构。具体可以使用MySQL的Cluster功能。</li>
</ul>
</li>
</ul>
<h2 id="管理维护篇"><a href="#管理维护篇" class="headerlink" title="管理维护篇"></a>管理维护篇</h2><h3 id="MySQL高级安装和升级"><a href="#MySQL高级安装和升级" class="headerlink" title="MySQL高级安装和升级"></a>MySQL高级安装和升级</h3><p>高级安装，即除RPM包以外的，二进制包和源码包安装两种方式</p>
<ul>
<li><p>升级：</p>
<ul>
<li>安装新版本MySQL</li>
<li><p>建表导数据，两种方式。</p>
<ul>
<li>第一种，<code>mysqladmin -h host -u user -p pwd create db_name</code>，<code>mysqldump --opt db_name | msyql -u user -p pwd db_name</code></li>
<li>第二种<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --tab=DUMPDIR db_name   # --tab不会生成SQL文本，而是对每个表生成.sql和.txt文件，分别保存表创建语句，纯数据文本</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将DUMPDIR目录文件转移到目标服务器上</span></span><br><span class="line">mysqladmin create db_name         # 创建数据库</span><br><span class="line">cat DUMPDIR/*.sql | mysql db_name # 创建表</span><br><span class="line">mysqlimport db_name DUMPDIR/*.txt # 加载数据</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>旧版本mysql数据库目录全部cp过来覆盖新版本，如 <code>cp -R /home/mysql_old/data/mysql /home/mysql_new/data/mysql</code></p>
</li>
<li>新版本MySQL shell中执行 mysql_fix_privilege_tables 升级权限表</li>
<li>重启，完成<h3 id="MySQL常用管理工具（全部都是命令行，而不是在shell内）"><a href="#MySQL常用管理工具（全部都是命令行，而不是在shell内）" class="headerlink" title="MySQL常用管理工具（全部都是命令行，而不是在shell内）"></a>MySQL常用管理工具（全部都是命令行，而不是在shell内）</h3>mysql、myisampack（MyISAM表压缩）、mysqladmin（侧重管理）、mysqlbinlog（日志管理）、mysqlcheck（MyISAM表维护）、mysqldump（数据导出）、<br>mysqlhotcopy（MyISAM热备份）、mysqlimport（数据导入）、mysqlshow（数据库对象查看）、perror（错误代码查看）、replace（文本替换工具，类似sed）。<h3 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h3>MySQL有四种日志，错误日志、二进制日志、查询日志、慢查询日志。日志默认似乎都在DATADIR目录下，并且除了错误日志，其他都默认关闭。<br>查看 DATADIR 命令：<code>SHOW VARIABLES LIKE &quot;%dir&quot;</code>。Mac上默认值是，<code>/usr/local/var/mysql/</code>。</li>
</ul>
</li>
<li>错误日志<br>记录了mysqld启动和停止时，以及服务器运行过程中发生任何严重错误时的相关信息。数据库出现故障无法使用时，可首先查看错误日志。<br>错误日志默认在DATADIR（数据目录）下，文件名为 host_name.err。比如我的Mac下文件名叫 jojo.local.err。</li>
<li>二进制日志<br>记录了所有DDL和DML语句，但是不包含查询语句。对于灾难时数据恢复起着极其重要的作用。<br><code>show binary logs</code>查看日志文件名，默认是host_name-bin.num。二进制日志默认是关闭的，<code>SHOW VARIABLES LIKE &quot;%log_bin%&quot;</code>，打开使用 <code>--log-bin</code>。<ul>
<li>三种日志格式：<br>statement语句格式，每一条对数据造成修改的SQL都会被记录在日志中。清晰易读，日志量小，对IO影响小，但是有时用于复制会出错。<br>row行格式，将每一行的变更记录都记录下来。比如全表更新的SQL，statement格式只记录一句，row格式会记录总行数的日志。缺点是日志量大，对IO影响大。<br>mixed格式，默认格式，混合了上述两种。默认情况下采用statement，但在特殊情况下采用row，比如客户端使用临时表、使用不确定函数等。</li>
<li>读取日志。二进制方式存储，所以要使用mysqlbinlog工具。如果是row格式，记得加上-v翻译字符。</li>
<li>删除日志。<ul>
<li><code>reset master</code>。全部清除</li>
<li><code>purge master logs to &#39;mysql-bin.000006&#39;</code>。删除某个编号之前的日志。</li>
<li><code>purge master logs before &#39;2007-08-10 04:07:00&#39;</code>。删除某个日期之前的日志。</li>
<li>启动参数<code>--expire_logs_days=3</code>。重启后即可 <code>mysqladmin flush-log</code> 触发日志文件更新。</li>
</ul>
</li>
</ul>
</li>
<li>查询日志<br>查询日志记录了客户端所有语句，而二进制不包含只查询的语句。<br>可以设置 <code>--log-output=TABLE,FILE|NONE</code>，表示将日志保存在表和文件中（或不保存）。这个对查询日志、慢查询日志都管用。输出到表时，慢查询精确到秒，输出到文件时精确到微妙<br>host_name.log 日志文件存储的是纯文本，可以直接读取。对于访问频繁的系统，此日志对性能影响较大，一般建议关闭。</li>
<li>慢查询日志<br>记录了所有，执行时间超过 long_query_time（默认10秒）设置值且扫描记录不小于 min_examined_row_limit的所有SQL语句。<br>默认情况下，管理语句 和 不使用索引查询 的语句都不会被记录。<br>默认日志名，host_name-slow.log，纯文本保存可直接查看。打开慢查询日志 <code>--slow_query_log</code>，指定日志路径 <code>slow_query_log_file</code>。<br>如果慢查询日志记录有很多，可使用 mysqldumpslow 工具，对慢查询日志进行分类汇总。</li>
<li>第三方日志分析工具（笔记中除了特别注明第三方，其他都是自带工具）<br>mysqlsla 可以分析多种日志，不限于某种类型。具体使用看文档，这里不记录。<br>还有些其他日志分析工具，myprofi、mysql-explain-slow-log、mysqllogfilter等。<h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3>分为逻辑备份与物理备份，逻辑备份不分引擎，而对于物理备份，不同引擎有不同的备份方法</li>
<li><p>逻辑备份<br>将数据库中的数据备份为一个文本文件，备份的文件可以被查看和编辑。通常使用mysqldump来备份。<br>为了保证数据一致性，MyISAM备份时加上-l参数，给所有表加读锁；对于InnoDB，可用–single-transaction，得到一个快照（dump过程中不会看到其他会话提交的数据）。下面详细说恢复</p>
<ul>
<li><p>完全恢复</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p test &lt; test.dmp                           # 恢复某个时间的备份</span><br><span class="line">mysqlbinlog localhost-bin.000015 | mysql -uroot -p test   # 使用mysqlbinlog恢复自备份以来的binglog（前提是你知道从哪开始）</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于时间点恢复（假设10点进行了误操作，所以需要按照时间跳过误操作语句）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinglog --stop-date="2005-04-20 9:59:59" localhost-bin.000015 | mysql -uroot -p</span><br><span class="line">mysqlbinglog --start-date="2005-04-20 10:01:00" localhost-bin.000015 | mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于位置恢复（更精确，因为同一时间可能有多个SQL）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinglog --stop-date="2005-04-20 9:55:50" --start-date="2005-04-20 10:05:00" localhost-bin.000015 &gt; /tmp/mysql_restore.sql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据导出的文件，找到出问题语句前后的位置号。如前后位置号分别为 368312 和 368315。</span></span><br><span class="line">mysqlbinglog --stop-position="368312" localhost-bin.000015 | mysql -uroot -p</span><br><span class="line">mysqlbinglog --start-position="368315。" localhost-bin.000015 | mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>物理备份与恢复</p>
<ul>
<li>冷备份。其实就是停掉数据库服务，cp数据文件的方法。很少使用，因为应用一般不允许长时间停机</li>
<li><p>热备份。</p>
<ul>
<li>MyISAM。<br>操作方法的本质是，将要备份的表加读锁，然后cp数据文件到备份目录。<br>使用mysqlhotcopy工具；手工备份：<code>flush tables for read</code>，然后cp数据文件到备份目录即可。</li>
<li>InnoDB。介绍了收费第三方工具ibbackup。</li>
<li><p>Xtrabackup热备工具。这个第三方包包含两个工具，xtrabackup和innobackupex。<br>xtrabackup只能备份InnoDB和XtraDB两种，不能备份MyISAM；innobackupex是封装前者的Perl脚本，能备份InnoDB和MyISAM，同样备份MyISAM的时候加全局读锁。<br>参考： <a href="http://devliangel.blog.51cto.com/469347/1374232" target="_blank" rel="noopener">innobackupex在线增量备份及恢复mysql数据库</a>，<a href="http://blog.csdn.net/dbanote/article/details/13295727" target="_blank" rel="noopener">innobackupex在线增量备份及恢复</a></p>
<ul>
<li><p>全量备份</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 进行全备</span></span><br><span class="line">innobackupex --user=back --password=123 --defaults-file=/etc/my.cnf /data/backup/hotbackup/full --no-timestamp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复之前，停止数据库，并删除数据和日志文件（可以备份）。备份删除这两步也可以变成，mv命令重命名，然后mkdir原名空目录。</span></span><br><span class="line">mysqld stop               # 停掉服务</span><br><span class="line">cp -a mysql/ mysql.bak    # archive备份要删除的文件目录</span><br><span class="line">cd mysql &amp;&amp; rm -rf *      # 执行删除</span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 恢复全备，分两步，第一步 apply-log，第二步 copy-back。</span></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --use-memory=20G --apply-log /data/backup/hotbackup/full</span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=back --copy-back /data/backup/hotbackup/full</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改权限</span></span><br><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br><span class="line">mysqld start</span><br></pre></td></tr></table></figure>
</li>
<li><p>增量备份<br>增量备份时，要先进行一次全量备份，第一次增量是基于全量的，之后的增量是基于上一次增量备份</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 假设已经全量备份过一次，目录为 /data/backup/hotbackup/base，创建第一次增量 incremental_one</span></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=back --incremental /data/backup/hotbackup/incremental_one --incremental-basedir=/data/backup/hotbackup/base</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次备份 incremental_two</span></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=back --incremental /data/backup/hotbackup/incremental_two --incremental-basedir=/data/backup/hotbackup/incremental_one</span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增量恢复。 注意一开始要加 --redo-only 参数，只应用xtrabackup日志中已提交的事务数据，不回滚未提交的数据。最后一次不加，回滚未提交。</span></span><br><span class="line">innobackupex --apply-log --redo-only /data/backup/hotbackup/base</span><br><span class="line"><span class="meta">#</span><span class="bash"> 两次增量备份应用到基础备份，最后一次去掉 --redo-only</span></span><br><span class="line">innobackupex --apply-log --redo-only /data/backup/hotbackup/base --incremental-dir=/data/backup/hotbackup/incremental_one/</span><br><span class="line">innobackupex --apply-log /data/backup/hotbackup/base --incremental-dir=/data/backup/hotbackup/incremental_two/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有合在一起的基础备份整体一次apply，回滚未提交数据</span></span><br><span class="line">innobackupex --apply-log /data/backup/hotbackup/base</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后面依旧是停止数据库，复制数据，赋权，启动数据库。这里不赘述</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不完全恢复<br>innobackupex备份的文件夹中，有些文件包含有用的信息。如 xtrabackup_binlog_info 能查看备份结束时binglog的名称和位置，根据这个能利用binlog进行不完全恢复。</p>
</li>
<li>克隆slave。<br>在线添加从库时，常用的参数是，–slave-info 和 –safe-slave-backup。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>表的导入导出。<br>导出：<code>select * from tbl_name into outfile &#39;target_file&#39; [options]</code>；或者mysqldump。<br>导入：<code>load data infile &#39;source_file&#39; into table tbl_name [options]</code>；或者mysqlimport。<h3 id="MySQL权限与安全"><a href="#MySQL权限与安全" class="headerlink" title="MySQL权限与安全"></a>MySQL权限与安全</h3>权限的存取，会用到mysql数据库的user、host和db三张表，主要是user。账号的增删改查不记录了。<br>安全上，避免以root权限运行MySQL。以root用户启动（Linux的用户）MySQL，任何具有FILE权限的用户（MySQL用户）都能够读写root用户的文件。<h3 id="MySQL监控"><a href="#MySQL监控" class="headerlink" title="MySQL监控"></a>MySQL监控</h3>主要是讲Zabbix，配合使用Fromdual插件，用于监控MySQL的MPM插件<h3 id="MySQL常见问题"><a href="#MySQL常见问题" class="headerlink" title="MySQL常见问题"></a>MySQL常见问题</h3></li>
<li><p>忘记root密码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭MySQL服务后，带 --skip-grant-tables 参数重启，跳过权限表验证</span></span><br><span class="line">mysqld_safe --skip-grant-tables --user=mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不用密码以root登录MySQL</span></span><br><span class="line">mysql -uroot</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> password=password(<span class="string">'123'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span> and host=<span class="string">'localhost'</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;    <span class="comment"># 刷新权限表，权限认证重新生效。重新正常以root登录即可。</span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html" target="_blank" rel="noopener">官方文档说明</a></p>
</li>
<li>mysql.sock 丢失后如何连接数据库<br>如果指定localhost作为主机名，则默认使用UNIX套接字文件连接，而不是TCP/IP。而这个套接字文件（一般叫mysql.sock）经常会被删除。<br>这时候，手动指定连接协议即可：<code>mysql --protocol=TCP -uroot -p -hlocalhost</code>。</li>
</ul>
<h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h2><h3 id="MySQL复制（Replication）——《高性能MySQL》主要内容之一"><a href="#MySQL复制（Replication）——《高性能MySQL》主要内容之一" class="headerlink" title="MySQL复制（Replication）——《高性能MySQL》主要内容之一"></a>MySQL复制（Replication）——《高性能MySQL》主要内容之一</h3><ul>
<li>复制概述<br>原理：MySQL主库把数据变更记录在binlog中，主库推送binlog中的事件到从库的中继日志Relay Log，从库对这些日志重新执行（也叫重做），以保持数据一致<br>3个线程：从库启动复制时，创建IO线程连接主库，主库随后创建binlog dump线程读取数据库事件并发送给IO线程，IO线程更新从库relay log，从库SQL线程读取中继日志并应用。<br>relay log格式内容等基本和binlog一样，只不过会被SQL线程删除。另外，从库还会创建 maser.info 和 relay-log.info 保存从库IO线程读取主库binlog和SQL线程应用中继的进度<br>三种binlog格式，对应三种复制模式。基于语句的复制SBR，基于行的复制RBR，混合模式复制。<ul>
<li>复制的常见架构<ul>
<li>一主多从复制架构。<br>主库读取压力很大时，配置这个架构实现读写分离。把读请求通过负载均衡分布到多个从库上。主库宕机时，可把一个从库切换为主库继续提供服务。</li>
<li>多级复制架构。<br>一主多从架构，由于复制是主库主动推送，主库IO压力和网络压力会随从库增加而增加。<br>多级架构，就是在一主多从的架构下，主库和从库之间增加二级主库。这样主库只要负责写请求和推送给一个二级主库，减轻主库压力。缺点是，两次复制延时比一次复制延时要大。<br>可在二级主库上选择表引擎为BLACKHOLE，来降低多级复制的延时。写入BLACKHOLE表的数据并不会写到磁盘上，永远是空表，数据变更仅仅是在binlog中记录。<br>注意，从库默认是不记录binlog的，如果它本身作为下一级的主库的话（如二级主库），需要打开 log-slave-updates 配置。</li>
<li>双主复制/Dual Master 架构<br>两个主库互为主从，避免了对主库进行维护带来的额外搭建从库的麻烦。<br>双主复制可以和主从复制联合使用，双主多级架构。</li>
</ul>
</li>
</ul>
</li>
<li><p>复制搭建</p>
<ul>
<li>异步复制<br>在主库上锁表备份，将主库备份恢复到从库上；主从库在配置文件中设置唯一的server-id的值，都重启，从库重启时使用–skip-slave-start，这样不会立即启动复制进程，方便进一步配置<br>在从库上配置 <code>change master to ...</code>（其中file和position信息在主库上<code>show master status</code>查看，是从库复制的目的坐标），然后启动salve线程，<code>start slave</code>。<code>show processlist</code> 查看进程，看是否连接上。<br>（<code>change master to</code>的配置参数包括，master_host、master_port、master_user、master_password、master_log_file、master_log_pos 等）<br>数据完整性依赖主库binlog，即使主库宕机，也可以把丢失的部分同步到从库上：高可用MHA架构自动抽取缺失部分补全从库；或者5.6的global transaction identitifier特性抽取。<br>为保护binlog，MySQL引入sync_binlog参数控制binlog刷新到磁盘（写binlog）的频率。为0时表示不控制，由文件系统自己控制文件的缓存刷新；为n时，表示每n次事务提交，刷新到磁盘</li>
<li>半同步复制<br>5.5以前的异步复制，有延迟隐患：从库尚未得到主库binlog，主库宕机且binlog丢失，从库就损失了这个事务，造成主从不一致。<br>异步复制，主库执行完提交操作、写入binlog后，即可返回客户端；而半同步复制，必须等待其中一个从库也接收binglog事务并写入中继日志，主库才返回提交操作成功给客户端<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设是在异步复制的基础上，修改为半同步复制 semi-sync。半同步是基于插件的</span></span><br><span class="line"><span class="keyword">select</span> @@have_dynamic_loading;                                      <span class="comment">-- 是否支持动态增加插件</span></span><br><span class="line"><span class="comment">-- 检查 $MYSQL_HOME/lib/plugin 目录下是否存在插件 semisync_master.so 和 semisync_slave.so。</span></span><br><span class="line"><span class="keyword">install</span> <span class="keyword">plugin</span> rpl_semi_sync_master <span class="keyword">soname</span> <span class="string">'semisync_master.so'</span>;    <span class="comment">-- 主库安装插件，从库改成slave不赘述</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.plugin;                                         <span class="comment">-- 检查是否安装成功</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> rpl_semi_sync_master_enabled=<span class="number">1</span>;                          <span class="comment">-- 开启半同步，从库改成slave。</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> rpl_semi_sync_master_timeout=<span class="number">30000</span>;    <span class="comment">-- 主库在等待这个参数毫秒超时后，自动转为异步复制。在此基础上从库正常连上后，又会自动切换回半同步</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span> io_thread; <span class="keyword">start</span> <span class="keyword">slave</span> io_thread;                        <span class="comment">-- 从异步复制切换过来，需要重启从库io线程。如果是新配置的半同步不需要</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">"%semi_sync%"</span>;                                     <span class="comment">-- 查看状态值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>日常管理维护</p>
<ul>
<li>查看从库状态。<code>show slave status \G</code>，关注IO和SQL两个参数，代表相应线程运行状况</li>
<li><p>主从维护同步<br>OLTP这样的系统，主库更新频繁，从库因各种原因导致更新缓慢，使得主从库之间数据差距越来越大，所以需要定期进行主从数据同步。做法是负载较低时阻塞主库更新，强制同步</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> tabls <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;                       <span class="comment">-- 主库阻塞更新</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;                               <span class="comment">-- 主库日志名和偏移量，是从库复制的目的坐标（同异步复制配置部分）</span></span><br><span class="line"><span class="keyword">select</span> master_pos_waite(<span class="string">'msyql-bin.123456'</span>,<span class="string">'973'</span>) <span class="comment">-- 从库执行，会阻塞直到从库达到指定日志文件和偏移量后，返回0。返回1表示超时退出。</span></span><br><span class="line"><span class="keyword">unlock</span> tabls;                                     <span class="comment">-- 主库解锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从库复制出错<br>这里书里面似乎写错了。没有处理复制出错的问题，变成跳过来自主库的语句了，使用 <code>set global sql_slave_skip_count=n</code>。</p>
</li>
<li>查看从库复制进度<br>这个进度，帮助我们判断是否需要手工进行主从同步，也可以判断从库中统计数据的覆盖范围。<br>可以通过查看 show processlist 的slave_sql_running（SQL线程用于读取中继日志）的 time 值，它记录了从库当前执行SQL的时间戳与系统时间的差距，单位秒。</li>
<li>提高复制性能<br>高并发下主库是多线程写入，而从库默认只有一个SQL线程在应用日志，容易出现从库追不上主库。 show slave status 的 seconds_behind_master是预估落后的秒数，不准<ul>
<li>方案一：一主多从下，通过设置replicate-do-db、replicate-ignore-db等参数，使每个从库上只同步部分表，减少需要写入的数据。<br>优点是自由拆分从库，分散热点数据；缺点是维护起来不够简洁，且一旦主库宕机不好处理，其他从库上没有完整数据。</li>
<li>方案二：5.6提供了基于schema的多线程复制，设置 slave_parallel_workers 参数，启动多个SQL线程。书中建议具体内容查看文档。</li>
</ul>
</li>
</ul>
</li>
<li><p>切换主从库<br>假设有个复制环境，主库M，两个从库S1、S2。当M故障时，需要将S1切换成主库，同时将S2的主库修改为S1。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先关闭IO线程，确认从库中所有的relay log都执行完成</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span> io_thread;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;             <span class="comment">-- 状态时 has read all relay log 即可。</span></span><br><span class="line"><span class="comment">-- 将S1切换成主库</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>; <span class="keyword">reset</span> <span class="keyword">master</span>;</span><br><span class="line"><span class="comment">-- 修改S2的配置</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=&lt;S1&gt;;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>之后，通知客户端程序将应用指向S1，并删除S1的 master.info 和 relay-log.info，否则重启还会按照从库启动。<br>（注意：这里默认S1是打开log-bin的，重置成主库后就有binlog；且关闭 log-slave-updates，否则重置成主库后，可能把已执行过的binlog传给S2）</p>
<h3 id="MySQL-Cluster（集群）"><a href="#MySQL-Cluster（集群）" class="headerlink" title="MySQL Cluster（集群）"></a>MySQL Cluster（集群）</h3><p>集群是一组节点的集合。节点是逻辑概念，一台计算机上可以有一至多个节点。节点功能各不相同，有的存放数据（数据节点），有的存放表结构（SQL节点），有的管理其他节点（管理节点）<br>MySQL使用NDB引擎来对数据节点的数据进行存储，NDB引擎以前支持基于内存的数据表，5.1开始支持基于磁盘的数据表。MySQL Cluster的SQL节点，可以理解为应用与数据节点的桥梁<br>启动时，按照管理节点、数据节点、SQL节点的顺序，依次启动服务，然后再使用集群客户端，查看相关信息。<br>使用时，在任意一个SQL节点中，建表插入数据（具体怎么存储书中没说），在另一个节点中查询时正常。（必须使用NDB引擎）</p>
<h3 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h3><p>具体安装测试这里不记录，安装成功后内部是故障自动切换的。</p>
</li>
<li>MMM架构<br>MMM（Master-Master replication manager for MySQL）是一套支持双主故障切换和双主日常管理的脚本程序。<br>名为双主，同一时刻只允许对一台写入，另一台备选主上提供部分读。MMM主要是实现故障切换的功能，另外其内部附加的工具脚本也可实现多slave的读负载均衡。<br>MMM适合于对数据一致性要求不高、但想最大程度保证业务可用性的场景。</li>
<li>MHA架构（书中评价更高）<br>MHA（Master High Availability）是比较成熟的高可用方案，且能最大程度上保证数据一致性。<br>它由两部分组成，MHA Manager管理节点和MHA Node数据节点。管理节点可以部署在独立机器上或某个slave上，管理主从复制；数据节点运行在每台MySQL服务器上。<br>目前MHA主要支持一主多从架构，至少有三台数据库服务器，一主两从，一个master，一个备用master，一个从。淘宝改造的TMHA支持一主一从。<br>工作原理：从宕机master保存binglog，识别含有最新更新的slave，应用差异的中继日志到其他slave，应用从master保存的binlog，提升一个slave为新master，其他slave连接新master进行复制。</li>
</ul>
<hr>
<p>总结：使用MySQL的核心是索引（index only查询）、锁。多使用show variable可以查看参数（@@开头的是系统参数，@开头的是用户定义参数，使用select查看）。优化SQL的步骤。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag">#读书笔记</a>
          
            <a href="/tags/MySQL/" rel="tag">#MySQL</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/31/ruby-design-patterns/" rel="next" title="《Ruby设计模式》笔记">
                <i class="fa fa-chevron-left"></i> 《Ruby设计模式》笔记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/12/network-protocols/" rel="prev" title="网络协议——写给每个懂点编程的同学">
                网络协议——写给每个懂点编程的同学 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="daorren" />
          <p class="site-author-name" itemprop="name">daorren</p>
          <p class="site-description motion-element" itemprop="description">Call me Maybe</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/daorren/" target="_blank" title="Douban">
                  
                    <i class="fa fa-fw fa-film"></i>
                  
                  Douban
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/daorren" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分-基础篇"><span class="nav-number">1.</span> <span class="nav-text">第一部分 基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#支持的数据类型"><span class="nav-number">1.1.</span> <span class="nav-text">支持的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用函数"><span class="nav-number">1.2.</span> <span class="nav-text">常用函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二部分-开发篇"><span class="nav-number">2.</span> <span class="nav-text">第二部分 开发篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#表类型（存储引擎）的选择"><span class="nav-number">2.1.</span> <span class="nav-text">表类型（存储引擎）的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择合适的数据类型"><span class="nav-number">2.2.</span> <span class="nav-text">选择合适的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符集的选择"><span class="nav-number">2.3.</span> <span class="nav-text">字符集的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的设计和使用"><span class="nav-number">2.4.</span> <span class="nav-text">索引的设计和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图"><span class="nav-number">2.5.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储过程与函数"><span class="nav-number">2.6.</span> <span class="nav-text">存储过程与函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#触发器"><span class="nav-number">2.7.</span> <span class="nav-text">触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务控制和锁定语句"><span class="nav-number">2.8.</span> <span class="nav-text">事务控制和锁定语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL安全问题"><span class="nav-number">2.9.</span> <span class="nav-text">SQL安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-MODE-及相关问题"><span class="nav-number">2.10.</span> <span class="nav-text">SQL MODE 及相关问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL分区"><span class="nav-number">2.11.</span> <span class="nav-text">MySQL分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三部分-优化篇"><span class="nav-number">3.</span> <span class="nav-text">第三部分 优化篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL优化"><span class="nav-number">3.1.</span> <span class="nav-text">SQL优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化数据库对象"><span class="nav-number">3.2.</span> <span class="nav-text">优化数据库对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁问题"><span class="nav-number">3.3.</span> <span class="nav-text">锁问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化MySQL-Server"><span class="nav-number">3.4.</span> <span class="nav-text">优化MySQL Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘IO问题"><span class="nav-number">3.5.</span> <span class="nav-text">磁盘IO问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用优化"><span class="nav-number">3.6.</span> <span class="nav-text">应用优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理维护篇"><span class="nav-number">4.</span> <span class="nav-text">管理维护篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL高级安装和升级"><span class="nav-number">4.1.</span> <span class="nav-text">MySQL高级安装和升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL常用管理工具（全部都是命令行，而不是在shell内）"><span class="nav-number">4.2.</span> <span class="nav-text">MySQL常用管理工具（全部都是命令行，而不是在shell内）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL日志"><span class="nav-number">4.3.</span> <span class="nav-text">MySQL日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#备份与恢复"><span class="nav-number">4.4.</span> <span class="nav-text">备份与恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL权限与安全"><span class="nav-number">4.5.</span> <span class="nav-text">MySQL权限与安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL监控"><span class="nav-number">4.6.</span> <span class="nav-text">MySQL监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL常见问题"><span class="nav-number">4.7.</span> <span class="nav-text">MySQL常见问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构篇"><span class="nav-number">5.</span> <span class="nav-text">架构篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL复制（Replication）——《高性能MySQL》主要内容之一"><span class="nav-number">5.1.</span> <span class="nav-text">MySQL复制（Replication）——《高性能MySQL》主要内容之一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-Cluster（集群）"><span class="nav-number">5.2.</span> <span class="nav-text">MySQL Cluster（集群）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高可用架构"><span class="nav-number">5.3.</span> <span class="nav-text">高可用架构</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">daorren</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
